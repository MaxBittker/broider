{"version":3,"sources":["state.ts","utils.ts","render.ts","index.ts"],"names":[],"mappings":"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","file":"border.f9697445.js","sourceRoot":"..","sourcesContent":["var tileSize = 7;\nvar pixelRatio = 4;\nvar editorRatio = 4 * pixelRatio;\n\nexport { tileSize, pixelRatio, editorRatio };\n","import { tileSize } from \"./state\";\n\nfunction newCell() {\n  let rows = new Array(tileSize).fill(0);\n  return rows.map((v, i) => new Array(tileSize).fill(0));\n}\nfunction newGrid() {\n  let rows = new Array(3).fill(0);\n  return rows.map((v, i) => {\n    let col = new Array(3).fill(0);\n    return col.map((v, i) => newCell());\n  });\n}\n\nfunction randomInt(amin, amax?: number) {\n  var min = amin;\n  var max = amax;\n  if (arguments.length == 1) {\n    min = 0;\n    max = amin;\n  }\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min)) + min;\n}\n\nfunction randomLoc() {\n  return [randomInt(3), randomInt(3), randomInt(tileSize), randomInt(tileSize)];\n}\nfunction getLoc(map: any[][][][], loc: number[]): number {\n  let r = loc.reduce((acc, i) => acc[i], map);\n  if (typeof r !== \"number\") {\n    return 0;\n  } else {\n    return r;\n  }\n}\n\nfunction setLoc(map: any[][][][], loc: any[], v: number = 1) {\n  let address = loc.slice(0, -1);\n  let lastPos = loc[loc.length - 1];\n  //   console.log(v);\n  address.reduce((acc, i) => acc[i], map)[lastPos] = v;\n}\n\nexport { newGrid, randomLoc, randomInt, getLoc, setLoc };\n","import { tileSize, pixelRatio, editorRatio } from \"./state\";\nimport { getLoc } from \"./utils\";\n\nlet canvas = <HTMLCanvasElement>document.getElementById(\"editor\");\nlet guideCanvas = <HTMLCanvasElement>document.getElementById(\"guide\");\nlet renderCanvas = <HTMLCanvasElement>document.getElementById(\"render\");\nvar ctx = canvas.getContext(\"2d\");\nvar guideCtx = guideCanvas.getContext(\"2d\");\nvar renderCtx = renderCanvas.getContext(\"2d\");\n\nfunction renderMap(map) {\n  renderCtx.fill();\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  for (let sx = 0; sx < 3; sx++) {\n    for (let sy = 0; sy < 3; sy++) {\n      for (let cx = 0; cx < tileSize; cx++) {\n        for (let cy = 0; cy < tileSize; cy++) {\n          let v = getLoc(map, [sx, sy, cx, cy]);\n\n          ctx.fillStyle = v == 1 ? \"#000\" : \"#fff0\";\n          renderCtx.fillStyle = v == 1 ? \"#000\" : \"#fff0\";\n          let gridX = (sx * tileSize + cx) * pixelRatio;\n          let gridY = (sy * tileSize + cy) * pixelRatio;\n\n          if (sx == 1 && sy == 1) {\n            continue;\n          }\n          renderCtx.clearRect(gridX, gridY, pixelRatio, pixelRatio);\n          renderCtx.fillRect(gridX, gridY, pixelRatio, pixelRatio);\n          gridX *= editorRatio / pixelRatio;\n          gridY *= editorRatio / pixelRatio;\n          ctx.fillRect(gridX + 1, gridY + 1, editorRatio - 1, editorRatio - 1);\n        }\n      }\n    }\n  }\n}\nfunction drawGuide() {\n  for (let index = 1; index < 3; index++) {\n    guideCtx.strokeStyle = \"#33f\";\n    guideCtx.lineWidth = 0.5;\n    let x = (index * canvas.width) / 3;\n    guideCtx.beginPath();\n    guideCtx.moveTo(x, 0);\n    guideCtx.lineTo(x, canvas.height);\n    guideCtx.stroke();\n    guideCtx.beginPath();\n    guideCtx.moveTo(0, x);\n    guideCtx.lineTo(canvas.height, x);\n    guideCtx.stroke();\n  }\n\n  for (let index = 0.0; index < 3 * tileSize; index++) {\n    guideCtx.strokeStyle = \"#ccc\";\n    let x = (index * canvas.width) / (3 * tileSize);\n    guideCtx.beginPath();\n    guideCtx.moveTo(x, 0);\n    guideCtx.lineTo(x, canvas.height);\n    guideCtx.stroke();\n    guideCtx.beginPath();\n    guideCtx.moveTo(0, x);\n    guideCtx.lineTo(canvas.height, x);\n    guideCtx.stroke();\n  }\n  let third = canvas.width / 3;\n  guideCtx.clearRect(third + 1, third + 1, third - 2, third - 2);\n  guideCtx.beginPath();\n  guideCtx.moveTo(third * 1, third * 2);\n  guideCtx.lineTo(third * 2, third * 1);\n  guideCtx.stroke();\n  guideCtx.beginPath();\n  guideCtx.moveTo(third * 1, third * 1);\n  guideCtx.lineTo(third * 2, third * 2);\n  guideCtx.stroke();\n}\n\nfunction setBorder() {\n  let dataURI = renderCanvas.toDataURL();\n  let target = <HTMLElement>document.getElementById(\"target\");\n\n  let style = <HTMLStyleElement>document.getElementById(\"border-style\");\n  if (style) style.remove();\n  style = document.createElement(\"style\");\n  style.id = \"border-style\";\n  document.head.appendChild(style);\n  //   style.sheet.insertRule(`.bordered {padding-right: ${(value / 5) * mult}px}`);\n  let css = `.bordered {\n    border-image:  url(\"${dataURI}\");\n    border-image-repeat:  round;\n    border-image-slice:  ${tileSize * pixelRatio};\n    border-image-width:  ${tileSize * pixelRatio}px;\n    border-width:  ${tileSize * pixelRatio}px;\n    border-style:  solid;\n  }`;\n  style.sheet.insertRule(css);\n  target.textContent = css;\n}\n\nfunction renderHover(map: any[][][][], x: number, y: number, loc: number[]) {\n  ctx.fillStyle = getLoc(map, loc) == 1 ? \"#228\" : \"#ddf\";\n  if (loc[0] == 1 && loc[1] == 1) {\n    return;\n  }\n  ctx.fillRect(\n    x * editorRatio + 1,\n    y * editorRatio + 1,\n    editorRatio - 1,\n    editorRatio - 1\n  );\n}\nexport { renderMap, drawGuide, setBorder, renderHover };\n","import { renderMap, setBorder, renderHover, drawGuide } from \"./render\";\nimport { tileSize, editorRatio, pixelRatio } from \"./state\";\nimport { newGrid, getLoc, setLoc } from \"./utils\";\n\nlet frame = <HTMLElement>document.getElementById(\"editor-frame\");\nlet canvas = <HTMLCanvasElement>document.getElementById(\"editor\");\nlet guideCanvas = <HTMLCanvasElement>document.getElementById(\"guide\");\nlet renderCanvas = <HTMLCanvasElement>document.getElementById(\"render\");\ncanvas.width = tileSize * editorRatio * 3;\ncanvas.height = tileSize * editorRatio * 3;\nguideCanvas.width = tileSize * editorRatio * 3;\nguideCanvas.height = tileSize * editorRatio * 3;\nrenderCanvas.width = tileSize * pixelRatio * 3;\nrenderCanvas.height = tileSize * pixelRatio * 3;\n\nwindow.setTimeout(() => {\n  frame.style.height = canvas.getBoundingClientRect().width + \"px\";\n}, 500);\n\nvar isDown = false;\nvar isErasing = false;\n\nlet map = newGrid();\n\ndrawGuide();\nrenderMap(map);\nsetBorder();\n\nlet draw = (e, isClick = false, isTouchStart = false) => {\n  let { left, top, width, height } = canvas.getBoundingClientRect();\n  let x = e.clientX - left;\n  let y = e.clientY - top;\n  let canvasX = (x / width) * canvas.width;\n  let canvasY = (y / height) * canvas.height;\n  let gridX = Math.floor(canvasX / editorRatio);\n  let gridY = Math.floor(canvasY / editorRatio);\n\n  let sx = Math.floor(gridX / tileSize);\n  let sy = Math.floor(gridY / tileSize);\n  let cx = gridX % tileSize;\n  let cy = gridY % tileSize;\n  let loc = [sx, sy, cx, cy];\n  let v = getLoc(map, loc);\n  if (isClick && v == 1) {\n    isErasing = true;\n  }\n\n  if (!isClick) {\n    v = 0;\n  }\n\n  if (isErasing) {\n    v = 1;\n  }\n\n  if (isDown) {\n    setLoc(map, loc, 1 - v);\n    renderMap(map);\n  } else {\n    renderMap(map);\n    renderHover(map, gridX, gridY, loc);\n  }\n  window.setTimeout(setBorder, 0);\n};\ncanvas.addEventListener(\"mousedown\", e => {\n  isDown = true;\n  draw(e, true);\n});\ncanvas.addEventListener(\"mousemove\", draw);\n\nwindow.addEventListener(\"mousedown\", () => {\n  isDown = true;\n});\nwindow.addEventListener(\"mouseup\", () => {\n  isDown = false;\n  isErasing = false;\n});\ncanvas.addEventListener(\"touchend\", e => {\n  isDown = false;\n  isErasing = false;\n});\ncanvas.addEventListener(\"touchstart\", e => {\n  isDown = true;\n\n  e.preventDefault();\n\n  const touches = e.targetTouches;\n  for (let i = 0; i < touches.length; i++) {\n    e[\"clientX\"] = touches[i].clientX;\n    e[\"clientY\"] = touches[i].clientY;\n    draw(e, true);\n  }\n});\ncanvas.addEventListener(\"touchmove\", e => {\n  e.preventDefault();\n  isDown = true;\n  if (isErasing) {\n    return;\n  }\n  const touches = e.targetTouches;\n  for (let i = 0; i < touches.length; i++) {\n    e[\"clientX\"] = touches[i].clientX;\n    e[\"clientY\"] = touches[i].clientY;\n    draw(e);\n  }\n  // isErasing = false;\n});\n\ncanvas.addEventListener(\"touchend\", e => {\n  e.preventDefault();\n  isDown = false;\n  isErasing = false;\n});\n"]}